<!doctype html>

<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Advanced Sudoku Solver — Visualizer</title>
<style>
  :root{
    --bg:#0f1724;--card:#0b1220;--muted:#94a3b8;--accent:#7c3aed;--accent-2:#06b6d4;--glass:rgba(255,255,255,0.04);
    --cell-size:56px;
  }
  *{box-sizing:border-box}
  body{font-family:Inter,ui-sans-serif,system-ui,-apple-system,'Segoe UI',Roboto,Helvetica,Arial; margin:0; min-height:100vh; background:linear-gradient(180deg,var(--bg),#061022 80%); color:#e6eef8; display:flex;align-items:center;justify-content:center;padding:28px}
  .app{width:100%;max-width:1100px}
  .top{display:flex;gap:18px;align-items:center;justify-content:space-between;margin-bottom:18px}
  .title{display:flex;gap:14px;align-items:center}
  .logo{width:64px;height:64px;border-radius:12px;background:linear-gradient(135deg,var(--accent),var(--accent-2));display:flex;align-items:center;justify-content:center;font-weight:700;font-size:20px;box-shadow:0 8px 30px rgba(0,0,0,0.5)}
  h1{margin:0;font-size:20px}
  p.lead{margin:0;color:var(--muted);font-size:13px}.container{display:grid;grid-template-columns:540px 1fr;gap:18px} .card{background:var(--card);border-radius:14px;padding:16px;box-shadow:0 6px 30px rgba(2,6,23,0.6);border:1px solid rgba(255,255,255,0.03)}

/* board / .board-wrap{display:flex;flex-direction:column;gap:12px;align-items:center} .board{display:grid;grid-template-columns:repeat(9, var(--cell-size));grid-template-rows:repeat(9,var(--cell-size));gap:6px;padding:12px;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));border-radius:12px} .cell{width:var(--cell-size);height:var(--cell-size);border-radius:10px;border:1px solid rgba(255,255,255,0.06);display:flex;align-items:center;justify-content:center;font-size:20px;background:transparent;cursor:pointer;position:relative} .cell input{width:100%;height:100%;text-align:center;border:0;background:transparent;color:inherit;font-size:20px;outline:none} .cell.prefill{font-weight:700;color:#d8e7ff} .cell.conflict{background:rgba(255,30,30,0.08);animation:shake .3s} .cell.mark{box-shadow:inset 0 0 0 2px rgba(124,58,237,0.12)} .cell.hint{background: rgba(6,182,212,0.06)} .cell.small{font-size:14px} @keyframes shake{0%{transform:translateX(-4px)}50%{transform:translateX(4px)}100%{transform:translateX(0)}} / thicker 3x3 borders */ .cell:nth-child(9n+1){margin-left:0} .board::after{content:'';position:absolute}

/* controls */ .controls{display:flex;flex-direction:column;gap:12px} .row{display:flex;gap:8px;align-items:center} label{font-size:13px;color:var(--muted)} .btn{background:linear-gradient(90deg,var(--accent),var(--accent-2));padding:8px 12px;border-radius:10px;border:0;color:white;cursor:pointer;font-weight:600} .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)} .secondary{background:#0b1220;border:1px solid rgba(255,255,255,0.04)}

.panel{display:flex;flex-direction:column;gap:10px} .stat{display:flex;gap:10px;align-items:center;color:var(--muted);font-size:13px}

.slider{width:100%} input[type=range]{-webkit-appearance:none;width:100%} input[type=range]::-webkit-slider-runnable-track{height:8px;background:linear-gradient(90deg,var(--accent),var(--accent-2));border-radius:999px} input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;margin-top:-6px;height:20px;width:20px;border-radius:50%;background:white}

.footer{display:flex;gap:8px;align-items:center;justify-content:space-between;margin-top:12px;color:var(--muted);font-size:13px}

/* responsive */ @media(max-width:980px){.container{grid-template-columns:1fr}.top{flex-direction:column;align-items:flex-start}.board{transform:scale(0.9)} }

/* utilities */ .muted{color:var(--muted)} .flex{display:flex;gap:8px;align-items:center}

</style>
</head>
<body>
  <div class="app">
    <div class="top">
      <div class="title">
        <div class="logo">S</div>
        <div>
          <h1>Advanced Sudoku Solver</h1>
          <p class="lead">Interactive visual solver • stepper • generator • hints • keyboard friendly</p>
        </div>
      </div>
      <div class="flex">
        <button class="btn" id="generateBtn">Generate</button>
        <button class="btn ghost" id="animateBtn">Animate Solve</button>
        <button class="btn secondary" id="solveBtn">Solve Instantly</button>
      </div>
    </div><div class="container">
  <div class="card board-wrap">
    <div style="display:flex;gap:14px;align-items:center;width:100%;justify-content:center;">
      <div class="muted">Difficulty:</div>
      <select id="difficulty">
        <option value="easy">Easy</option>
        <option value="medium" selected>Medium</option>
        <option value="hard">Hard</option>
        <option value="expert">Expert</option>
      </select>
      <div style="width:18px"></div>
      <button class="btn ghost" id="hintBtn">Hint</button>
      <button class="btn ghost" id="validateBtn">Validate</button>
      <button class="btn ghost" id="clearBtn">Clear</button>
    </div>

    <div id="board" class="board" aria-label="Sudoku board"></div>

    <div style="display:flex;gap:12px;align-items:center;margin-top:8px;width:100%;justify-content:center">
      <button class="btn" id="stepBackBtn">◀ Step</button>
      <input id="speed" class="slider" type="range" min="1" max="200" value="50" title="Animation speed (lower = faster)" />
      <button class="btn" id="stepFwdBtn">Step ▶</button>
    </div>

    <div class="footer">
      <div class="muted">Press numbers (1-9) to fill. Use Arrow keys to move. Click cell + press Del to clear.</div>
      <div class="muted">Ops: <span id="ops">0</span> • Depth: <span id="depth">0</span></div>
    </div>
  </div>

  <div class="card panel">
    <div class="row"><label>Solver Controls</label></div>
    <div class="row"><button class="btn" id="countSolutionsBtn">Check Unique</button><button class="btn ghost" id="exportBtn">Export</button><button class="btn ghost" id="importBtn">Import</button></div>

    <div class="row"><label>Samples</label></div>
    <div class="row"><button class="btn ghost" data-sample="easy">Load Easy</button><button class="btn ghost" data-sample="medium">Load Medium</button><button class="btn ghost" data-sample="hard">Load Hard</button></div>

    <div class="row"><label>Stats</label></div>
    <div class="stat">Solved cells: <strong id="filled">0</strong> / 81</div>
    <div class="stat">Time: <strong id="timer">0.00s</strong></div>

    <div style="height:12px"></div>
    <div class="row"><label>Advanced</label></div>
    <div class="row"><button class="btn ghost" id="generateUniqueBtn">Generate (unique)</button><button class="btn ghost" id="downloadBtn">Download</button></div>

    <div style="height:10px"></div>
    <div class="muted">Tip: Animate Solve shows step-by-step backtracking. Use speed slider to control frame delay.</div>
  </div>
</div>

  </div><script>
// ----------------- Core Board State -----------------
const BOARD_SIZE = 9;
let board = Array.from({length:9},()=>Array(9).fill(0));
let prefilled = Array.from({length:9},()=>Array(9).fill(false));
let ops = 0, maxDepth = 0;
let animationSteps = []; // {r,c,val,action}
let animIndex = 0;
let animTimer = null;
let animDelay = 50; // ms per step (lower = faster)
let solverStart = 0;

const boardEl = document.getElementById('board');
const opsEl = document.getElementById('ops');
const depthEl = document.getElementById('depth');
const filledEl = document.getElementById('filled');
const timerEl = document.getElementById('timer');

function makeBoardDOM(){
  boardEl.innerHTML='';
  for(let r=0;r<9;r++){
    for(let c=0;c<9;c++){
      const cell = document.createElement('div');
      cell.className='cell';
      cell.dataset.r=r;cell.dataset.c=c;
      // thick borders for 3x3
      if(c%3===2) cell.style.marginRight='4px';
      if(r%3===2) cell.style.marginBottom='4px';
      const inp = document.createElement('input');
      inp.type='text'; inp.maxLength=1; inp.inputMode='numeric';
      inp.addEventListener('keydown', handleKeyDown);
      inp.addEventListener('input', handleInput);
      cell.appendChild(inp);
      cell.addEventListener('click', ()=>{inp.focus()});
      boardEl.appendChild(cell);
    }
  }
}

function renderBoard(){
  let filled=0;
  const cells = boardEl.querySelectorAll('.cell');
  cells.forEach(div=>{
    div.classList.remove('prefill','conflict','mark','hint');
    const r = +div.dataset.r, c=+div.dataset.c;
    const inp = div.querySelector('input');
    const val = board[r][c];
    inp.value = val===0?'':val;
    if(prefilled[r][c]) div.classList.add('prefill');
    if(val!==0) filled++;
  });
  filledEl.textContent = filled;
  opsEl.textContent = ops;
  depthEl.textContent = maxDepth;
}

function setCell(r,c,val,mark=false){
  board[r][c]=val;
  const cell = boardEl.children[r*9+c];
  if(mark) cell.classList.add('mark');
  else cell.classList.remove('mark');
  renderBoard();
}

function clearAll(){
  board = Array.from({length:9},()=>Array(9).fill(0));
  prefilled = Array.from({length:9},()=>Array(9).fill(false));
  animationSteps = []; animIndex=0; ops=0; maxDepth=0; stopAnimation(); renderBoard();
}

// ----------------- Input / Keyboard -----------------
let focusedR=0, focusedC=0;
function handleKeyDown(e){
  const inp = e.target;
  const parent = inp.parentElement;
  const r = +parent.dataset.r, c = +parent.dataset.c;
  focusedR=r; focusedC=c;
  if(e.key>= '1' && e.key<='9'){
    e.preventDefault(); inp.value=e.key; board[r][c]=parseInt(e.key,10); prefilled[r][c]=false; renderBoard();
  } else if(e.key==='Backspace' || e.key==='Delete'){
    e.preventDefault(); inp.value=''; board[r][c]=0; renderBoard();
  } else if(e.key==='ArrowRight'){ e.preventDefault(); moveFocus(r,c,0,1); }
  else if(e.key==='ArrowLeft'){ e.preventDefault(); moveFocus(r,c,0,-1); }
  else if(e.key==='ArrowDown'){ e.preventDefault(); moveFocus(r,c,1,0); }
  else if(e.key==='ArrowUp'){ e.preventDefault(); moveFocus(r,c,-1,0); }
}
function handleInput(e){
  const v = e.target.value.replace(/[^1-9]/g,'');
  e.target.value = v;
  const parent = e.target.parentElement; const r=+parent.dataset.r,c=+parent.dataset.c;
  board[r][c] = v===''?0:parseInt(v,10);
  prefilled[r][c]=false;
  renderBoard();
}
function moveFocus(r,c,dr,dc){
  let nr=(r+dr+9)%9, nc=(c+dc+9)%9;
  const idx = nr*9+nc; const cell = boardEl.children[idx]; const inp = cell.querySelector('input'); inp.focus();
}

// ----------------- Validation -----------------
function isValidPlacement(boardLocal,row,col,num){
  for(let c=0;c<9;c++) if(boardLocal[row][c]===num) return false;
  for(let r=0;r<9;r++) if(boardLocal[r][col]===num) return false;
  const br = Math.floor(row/3)*3, bc = Math.floor(col/3)*3;
  for(let r=br;r<br+3;r++) for(let c=bc;c<bc+3;c++) if(boardLocal[r][c]===num) return false;
  return true;
}

function validateBoard(){
  // highlight conflicts
  const conflicts = [];
  for(let r=0;r<9;r++){
    for(let c=0;c<9;c++){
      const v = board[r][c]; if(v===0) continue;
      board[r][c]=0;
      if(!isValidPlacement(board,r,c,v)) conflicts.push([r,c]);
      board[r][c]=v;
    }
  }
  // add classes
  boardEl.querySelectorAll('.cell').forEach((cell)=>cell.classList.remove('conflict'));
  conflicts.forEach(([r,c])=> boardEl.children[r*9+c].classList.add('conflict'));
  return conflicts.length===0;
}

// ----------------- Solver (with steps recording) -----------------
function findEmpty(boardLocal){
  for(let r=0;r<9;r++) for(let c=0;c<9;c++) if(boardLocal[r][c]===0) return [r,c];
  return null;
}

function solveBacktrackSteps(boardLocal){
  // returns true if solved, records steps
  const spot = findEmpty(boardLocal);
  if(!spot) return true;
  const [r,c] = spot;
  for(let n=1;n<=9;n++){
    if(isValidPlacement(boardLocal,r,c,n)){
      ops++; maxDepth = Math.max(maxDepth, countFilled(boardLocal));
      animationSteps.push({r,c,val:n,action:'place'});
      boardLocal[r][c]=n;
      if(solveBacktrackSteps(boardLocal)) return true;
      animationSteps.push({r,c,val:0,action:'remove'});
      boardLocal[r][c]=0;
    }
  }
  return false;
}

function solveInstant(){
  stopAnimation(); animationSteps=[]; ops=0; maxDepth=0; solverStart=performance.now();
  const copy = board.map(r=>r.slice());
  if(!validateBoard()){
    // still attempt
  }
  const ok = solveBacktrackSteps(copy);
  const took = (performance.now()-solverStart)/1000;
  if(ok){ board = copy; renderBoard(); alert('Solved in '+took.toFixed(3)+'s, ops='+ops); }
  else alert('No solution found');
}

// ----------------- Count Solutions (uniqueness) -----------------
function countSolutions(boardLocal,limit=2){
  // backtracking that counts up to limit
  function helper(b){
    if(count>=limit) return; // early stop - use outside closure
    const spot = findEmpty(b);
    if(!spot){ count++; return; }
    const [r,c]=spot;
    for(let n=1;n<=9;n++){
      if(isValidPlacement(b,r,c,n)){
        b[r][c]=n;
        helper(b);
        b[r][c]=0;
        if(count>=limit) return;
      }
    }
  }
  let count=0; helper(boardLocal.map(r=>r.slice())); return count;
}

// ----------------- Animation Player -----------------
function playAnimation(){
  if(animationSteps.length===0){ alert('No animation steps recorded. Click Animate Solve to generate.'); return; }
  stopAnimation(); animIndex=0; animDelay = Math.max(1, 201 - +document.getElementById('speed').value);
  animTimer = setInterval(()=>{
    if(animIndex>=animationSteps.length) { stopAnimation(); return; }
    const s = animationSteps[animIndex++];
    board[s.r][s.c]=s.val; renderBoard();
    // highlight cell briefly
    const cell = boardEl.children[s.r*9+s.c];
    cell.classList.add('mark');
    setTimeout(()=>cell.classList.remove('mark'), Math.max(60,animDelay-10));
  }, Math.max(8,animDelay));
}
function stopAnimation(){ if(animTimer){ clearInterval(animTimer); animTimer=null; } }

// ----------------- Utility -----------------
function countFilled(bd){ let c=0; for(let r=0;r<9;r++) for(let cc=0;cc<9;cc++) if(bd[r][cc]!==0) c++; return c; }

// ----------------- Generator (create solved board then remove cells ensuring unique solution) -----------------
function shuffle(array){ for(let i=array.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [array[i],array[j]]=[array[j],array[i]] } return array }

function generateSolved(){
  const b = Array.from({length:9},()=>Array(9).fill(0));
  function solveRandom(bd){
    const spot = findEmpty(bd); if(!spot) return true; const [r,c]=spot;
    const pool = shuffle([1,2,3,4,5,6,7,8,9].slice());
    for(let v of pool){ if(isValidPlacement(bd,r,c,v)){ bd[r][c]=v; if(solveRandom(bd)) return true; bd[r][c]=0; } }
    return false;
  }
  solveRandom(b); return b;
}

function generatePuzzle(difficulty='medium',unique=true){
  stopAnimation(); const solved = generateSolved();
  // remove cells based on difficulty
  let attempts = {easy:30,medium:40,hard:50,expert:55}[difficulty]||40;
  const puzzle = solved.map(r=>r.slice());
  while(attempts-->0){
    const r=Math.floor(Math.random()*9), c=Math.floor(Math.random()*9);
    if(puzzle[r][c]===0) continue;
    const backup=puzzle[r][c]; puzzle[r][c]=0;
    if(unique){ const solutions = countSolutions(puzzle,2); if(solutions!==1) puzzle[r][c]=backup; }
  }
  board = puzzle.map(r=>r.slice()); prefilled = board.map(r=>r.map(v=>v!==0)); renderBoard();
}

// ----------------- Event Hooks -----------------
makeBoardDOM(); renderBoard();

document.getElementById('solveBtn').addEventListener('click', ()=>{ solveInstant(); });

document.getElementById('animateBtn').addEventListener('click', ()=>{
  // prepare steps
  stopAnimation(); animationSteps=[]; ops=0; maxDepth=0; solverStart=performance.now();
  const copy = board.map(r=>r.slice());
  const ok = solveBacktrackSteps(copy);
  const took = (performance.now()-solverStart)/1000;
  if(ok){ playAnimation(); } else alert('No solution found');
});

document.getElementById('generateBtn').addEventListener('click', ()=>{
  const diff = document.getElementById('difficulty').value; generatePuzzle(diff,false);
});

document.getElementById('generateUniqueBtn').addEventListener('click', ()=>{
  const diff = document.getElementById('difficulty').value; generatePuzzle(diff,true);
});

document.getElementById('clearBtn').addEventListener('click', ()=>{ clearAll(); });

document.getElementById('validateBtn').addEventListener('click', ()=>{ const ok = validateBoard(); alert(ok? 'Board valid ✅':'Conflicts found ❌'); });

document.getElementById('hintBtn').addEventListener('click', ()=>{
  // find first empty and suggest a valid number (naive)
  for(let r=0;r<9;r++) for(let c=0;c<9;c++){
    if(board[r][c]===0){
      for(let n=1;n<=9;n++) if(isValidPlacement(board,r,c,n)){
        // highlight and place temporarily
        board[r][c]=n; boardEl.children[r*9+c].classList.add('hint'); setTimeout(()=>{ board[r][c]=0; boardEl.children[r*9+c].classList.remove('hint'); renderBoard(); },1000);
        board[r][c]=0; renderBoard(); return;
      }
    }
  }
  alert('No hints available');
});

document.getElementById('speed').addEventListener('input', (e)=>{/* speed read in playAnimation */});

document.getElementById('stepFwdBtn').addEventListener('click', ()=>{ // step forward single recorded step
  if(animationSteps.length===0){ alert('No recorded steps. Click Animate Solve first to generate steps.'); return; }
  if(animIndex<animationSteps.length){ const s = animationSteps[animIndex++]; board[s.r][s.c]=s.val; renderBoard(); }
});

document.getElementById('stepBackBtn').addEventListener('click', ()=>{
  if(animationSteps.length===0){ alert('No recorded steps. Click Animate Solve first to generate steps.'); return; }
  if(animIndex>0){ animIndex--; const s = animationSteps[animIndex]; // revert this step
    // find previous value by scanning back
    let prev = 0; for(let k=animIndex-1;k>=0;k--){ const sk = animationSteps[k]; if(sk.r===s.r && sk.c===s.c){ prev = sk.val; break; } }
    board[s.r][s.c]=prev; renderBoard(); }
});

document.getElementById('countSolutionsBtn').addEventListener('click', ()=>{
  const cnt = countSolutions(board, 3); alert('Solutions found (up to 3): '+cnt);
});

document.querySelectorAll('[data-sample]').forEach(btn=>btn.addEventListener('click',(e)=>{
  const k=e.target.dataset.sample; const SAMPLES={
    easy:[[5,3,0,0,7,0,0,0,0],[6,0,0,1,9,5,0,0,0],[0,9,8,0,0,0,0,6,0],[8,0,0,0,6,0,0,0,3],[4,0,0,8,0,3,0,0,1],[7,0,0,0,2,0,0,0,6],[0,6,0,0,0,0,2,8,0],[0,0,0,4,1,9,0,0,5],[0,0,0,0,8,0,0,7,9]],
    medium:[[0,0,0,0,0,7,0,9,0],[1,0,0,0,0,0,0,0,2],[0,0,0,5,0,0,0,0,0],[0,0,0,0,0,0,3,0,0],[0,0,0,6,0,1,0,0,0],[0,0,2,0,0,0,0,0,0],[0,0,0,0,8,0,0,0,0],[8,0,0,0,0,0,0,0,9],[0,4,0,0,0,0,0,0,0]],
    hard:[[0,0,0,0,0,0,0,1,2],[0,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,7,0,0],[0,9,0,0,0,0,0,0,0],[0,0,0,1,0,5,0,0,0],[0,0,0,0,0,0,0,8,0],[0,0,7,0,0,0,3,0,0],[0,0,0,0,0,0,0,0,0],[9,2,0,0,0,0,0,0,0]]
  };
  board = SAMPLES[k].map(r=>r.slice()); prefilled = board.map(r=>r.map(v=>v!==0)); renderBoard();
}));

// Export / Import
function exportBoard(){ const data = {board, prefilled}; const blob = new Blob([JSON.stringify(data)],{type:'application/json'}); const url = URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='sudoku-board.json'; a.click(); }
function importBoard(){ const inp = document.createElement('input'); inp.type='file'; inp.accept='application/json'; inp.onchange = ()=>{
  const file = inp.files[0]; const reader=new FileReader(); reader.onload=()=>{
    try{ const obj = JSON.parse(reader.result); if(obj.board){ board = obj.board.map(r=>r.slice()); prefilled = (obj.prefilled||board.map(r=>r.map(v=>v!==0))).map(r=>r.slice()); renderBoard(); } }
    catch(e){ alert('Invalid file'); }
  }; reader.readAsText(file);
}; inp.click(); }

document.getElementById('exportBtn').addEventListener('click', exportBoard);
document.getElementById('importBtn').addEventListener('click', importBoard);
document.getElementById('downloadBtn').addEventListener('click', ()=>{ const html = '<!doctype html><meta charset="utf-8"><title>Sudoku Puzzle</title><style>body{font-family:sans-serif;padding:20px}</style><pre>'+JSON.stringify(board)+'</pre>'; const blob=new Blob([html],{type:'text/html'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='sudoku-puzzle.html'; a.click(); });// Prevent focus outline ugly behaviour document.body.addEventListener('click', ()=>document.activeElement.blur());

// initialize with a sample (function init(){ makeBoardDOM(); generatePuzzle('medium',false); })();

</script>
</body>
</html>
